# golang

## 入门概念

1. 包的概念
    1. 一个文件夹
    2. main包是定义了独立可执行程序，main函数是入口
    3. 导入包的时候，不能多导入，不能少导入，否则无法编译通过
        1. goland和vscode都会自动检查

2. import之后，是func，var，const，type的声明

5. 不能随意添加换行符，(因为编译器会自动在特定的换行符后加上分号)
    1. 所以使用gofmt格式化

4. a[0:3] 是 3-0 三个元素，Args[m:n]，m不填，则是0，n不填，则是到结尾

5. i++ 是语句，不是表达式，所以不能赋值给其他变量

8. 两种for
    1. 在range上，_ ,arg  首项为下标，尾项为元素值
        1. go不允许 无用局部变量，用 _ 下划线
        2. 此种循环可以隐形的使用序列的长度，不用手动显性调用

9. map 相关
    1. make(map[string]int)，字符串为键，int为值 一个映射（字典）
    2. map 作为参数传给某参数时，相当有引用传递

8. 由于:= 短赋值，所以浮点数要写成0.0

9. io.Discard 作为垃圾桶

10. goroutine极简入门
    1. 一个函数，其中一个参数为channel,作为goroutine
    2. ch <- expression 向ch 传入一个值，
    3. <- ch  从ch 中接受值 （pritnln （<- ch）

11. 词法作用域相关概念（学习途中一股自动机的味道

## 基础数据类型概念

12. 位运算采用无符号整数，无符号数只有位运算和bit集合，分析二进制文件格式，哈希和加密的操作的时候使用，这是最安全的实践

13. int16 和 int32 不能直接相加，需要类型转换

14. printf 字符串，%[1]x 表示这个x 用第一个操作数给这个赋值， %#[1]x 表示输出0，0x ，0X的前缀，#号还可以表示用与golang类似的语法打印，比如打印结构体的时候，打印出每个成员的名字，%*s * 用于在字符串前填充一些空格，空格的数量由后面相应的参数指定

15. %q 打印出的是 '\n'  这样的字符

16. 0.0 可用0. 表示

17. 对于浮点数，失败的时候最好返回一个额外的变量表示失败，而不是采用NaN

18. 对于字符串，按照索引访问，则是按照字节访问，也就是说对于非ASCII 字符需要多个字节（是个引用类型？若我没理解错引用类型的概念的话，字符串不能修改

19. 原生字符串是用   \`   替换掉'  '  原生字符串没有任何转义操作，但是不能包含反引号

    1. 用于编写正则表达式

20. > 小知识，utf8 是go语言之父参与发明的

21. 通过DecodeRuneInString 返回两个值，一个是长度，另一个按照字符算的长度，BTW，range循环处理字符串的时候会自动解码，不用过于考虑。

22. bytes  包提供查询替换比较 截断 差分 合并的功能，strconv 提供itoa这样的功能，unicode用于给字符分类和大小写转换等

23. %T 打印类型

24. 常量声明的时候，如果省略初始化表达式，则用前面的常量的初始化 后面的值，比如a=1 b  c d=2 则b c 都声明为1

25. itoa 常量生成器，就是itoa 首个为0，然后在常量列表中，每一行是递增1，可以采用对itoa赋值的方式，按行给每个常量赋值

26. 常量可以无类型，无类型的常量能提供更高的精度

    1. 无类型 布尔，整数，字符，浮点数，复数，字符串
    
## 复合数据类型

### 数组
0. 虽然go中也有数组，但是一般采用的是切片slice
1. q:= [...]int {1,2,3}  ... 表示数组的长度是根据初始值的个数计算出的
2. q:= [...]string{USD:"ss",EUR :"sasd"}  这种情况下 Print EUR 为1 q[EUR] 为“sasd”
3. 按照上文的逻辑，同理得出 r:=[...]int{99:-1} 则长度为100，最后一个是-1，前面是0， 这种冒号的表示，前面是索引后面是值
4. 同样大小的数组类型是可以比较的（因为数组的长度也划为了数组类型）
5. go的函数是值传递，传入数组即低效又不能将更改反馈给调用者

### slice
    
0. slice是引用，不指定元素数量且不使用... 可声明一个切片
1. 对于slice，判断为空，用len==0 判断，不适用nil判断，nil的 slice除了等于nil外，和len为0的数组没有区别
2. 用make可创建指定容量和长度的slice
3. append（runes，r） 向runes切片附加r 元素，append（runes，a，b） 附加ab append（runes，runes...）附加一个自身
4. 由于append可能产生内存分配，所以不能确认在原slice上的操作是否会影响新的slice，所以通常是将append的返回结果，直接赋值给输入的slice    
    1. 实际上，对于任何可能导致长度容量或底层数组变化的操作，都应该这样赋值，因为长度，等是结构体里的东西

###  map
1. make(map[string]int)
2. map[string]int{ }
3. delete(mapName,"key") 删除key所对应的元素
4. 若不得不按序遍历map，则需要先对key进行排序，然后用排序过的key的切片上作forr
5. 通过 age ，ok ：= ages["bobs"] 的ok的值，判断bobs 的年龄是0还是真的不存在，ok是个布尔值
6. 可以使用map的key实现set集合的效果    
    1. 因为他们都是唯一的
   
7. 若想要key为slice类型，可以先完成一个 将slice转为对应的string类型辅助函数k，然后对map操作时，先用k转换slice m[k(list)]++ 这样
    8. 上文是非常有用的技术
    9. map[string]map[string]bool

### 结构体
1. 点操作符，对于指针和变量是同样的效果
2. 函数若返回是结构体的指针的话，可以在调用函数后，直接用   .   更改值，若是返回 值的话，则不能直接用 . 更改（因为不能确定这个值是不是一个变量
3. 结构体成员的顺序也决定着不同的结构体（不会对齐？不是，是不会优化到最对齐的样子）
4. 若结构体成员是大写开头，则是可导出的成员，它可以由可导出和不可导出的成员联合构成
5. 同样，结构体不能含有自身，但是可以含有自身的指针
6. 结构体初始化
    0. ```go
                   type Point struct {X,Y int}
                   p:=Point{0,2}
                   ```
    1. ```go
                   P:=Point{x:0}
                   ```

7. 一种是按照名字赋值，一种是按照结构体成员出现的顺寻赋值
    7. 结构体通过指针传入传出提高效率
        1. 在这个想法下，通常结构体的使用是 pp:=&Point{1,2}
       
8. 结构体是可以比较的（当内部成员都是可比的时候），所以可作key
9. 特性
    1. 只声明一个成员对应的数据类型而不指定成员的名字（匿名成员

             ```go
                   type Point struct{
                   	X,Y int
                   }
                   type Circle struct{
                   	Point
                   	Radius int
                   }
                   type Wheel struct{
                   	Circle
                   	Spokes int
                   }
                   
                   var w Wheel
                   w.Radius =5  //可以不考虑Circle，就能访问到半径，与w.Circle.Radius =5 这种写法一样（也就是说匿名变量的名字其实是类型名
                   //但是初始化的时候，应该是
                   w=Wheel{Circle{Point{8,8},5},10} //按顺序
                   w=Wheel{
                       Circle:Circle{
                           Point: Point{X:8,y:9},
                           Radius:5,
                       },
                       Spokes:20,
                   }
                   
                   ```
   3. 由上面的过程易得，不能同时包含两个类型相同的匿名成员，匿名成员也有可见性约束，若Point改为point，则在包外就不能简短方式访问了
   4. 还可以用于获取方法集（后详
### JSON
31. JSON

    1. tag 的作用，更改导出的json对象的键的名字，``\` json:"released"` \``     用反引号括起来（原生字面量），json开头表示控制encoding/json包的编码和解码行为，其他类似。

        1. 可以用于将驼峰命名更改为下划线命名法
        2. 可以添加omitempty选项，指当为空或零时，不生成对象

    2. 在解码的时候，可以通过定义合适的数据结构，选择性的解码json的返回对象（其中有用的数据成员），

        1. 比如定义一个只含有Title的结构体，然后调用 Unmarshal 解码，从而只从JSON中获取所有的title

        2. > url.QueryEscape函数，可用于对查询中的特殊字符进行转义操作

        3. Decoder 和Encoder，针对流的编码和解码
### 模板
32. 模板

    1. 将一个变量的值填充到一个文本或HTML格式模板的机制

    2. 但是模板要自己写

    3. 具体过程

        1. template.New 创建并返回一个模板

        2. template.FuncMap{"daysAge":daysAgo} ，注册模板中用到的函数

        3. Parse(templ) 解析模板（templ是常量模板字符串

        4. ```go
                   template.New("report").Funcs(template.FuncMap{"test":test}).Parse(templ)
                   ```
        5. 可以template.Must包裹上述语句，简化错误处理

        6. report.Execute(os.Stout,result) 输出填充好的模板

        7. html的模板解决了一些注入的问题

            1. 本质类似代码生成器，生成器就可控制参数生成出不该有的代码
            2. 同时会自动转义特殊字符，不会把<link\> 当作超链接处理（一种注入的方式）
