# 函数


1. 对于普通的函数，（非结构体构造），不能通过形参名指定变量的值，也没有默认值，只能类似C语言的函数那样使用

2. 没有函数体的函数声明，说明不是用GO语言实现的

3. 比如把切片作为参数传给一个递归函数，则被调用者修改的是传入的拷贝，可能会修改底座的数组，但是当函数返回时，调用方的切片与原本的值一致

4. go的栈式可变栈，所以递归时不用考虑溢出和安全问题

5. > GO的GC机制，只能回收不被使用的内存，不包括系统层面的资源（也就是套接字，打开的文件等

6. 调用接受多参数的函数时，可以将一个返回多参数的函数作为该函数的参数


     1. 在debug的时候常用到，用一条语句输出所有的返回值（打log的时候）

7. 一个惯例

    1. 函数的最后一个bool类型返回值是函数是否运行成功，error返回值，是函数的错误信息

8. bare return： 当一个函数所有返回值都有名字的时候，只用一个return 后面不用跟返回列表，即可返回所有的变量


          1. 补充，在函数声明里给返回值命名，类似于在函数体开头声明一些变量，然后返回这些变量

## GO的一个错误处理哲学
9. GO的一个错误处理哲学
    1. 函数运行失败时返回错误信息，这种错误信息被认为是预期会出现的值而不是异常，
    2. 从而避免了直接无脑throw掉
    3. 在这个哲学下的错误处理策略
        1. 传播错误，（子程序的失败是函数的失败，把失败一层层往外传播直到有人处理它
            1. 注意：在往外传播途中，每一层都可能附加上部分有助于错误处理的消息，比如，错误发生时已经完成了什么
            2. 通过fmt.Errorf函数，且附加的信息不应该有大写和换行
            3. 一般是把调用信息和参数信息传出去
        2. 重新尝试
            1. 在一个for循环中尝试，并当err ==nil 的时候break ，从而限制重试的次数
        3. 结束程序
            1. 应该只在main中出现这种行为
            2. log.Fatalf 函数，结束程序并发出错误信息
        4. 只输入错误信息，但是不中断运行
    4. 同时导致的编码风格
        1. 在检查某个子函数是否失败后，将失败处理的代码放在  成功的else 代码前，
        2. 若某个错误导致函数返回，则成功的逻辑代码直接放在函数体中

10. 函数是一等公民，但是不能比较，不能作为map的key

    1. > string.Map(func,"sdsad") 对字符串里的每一个值调用一次func函数
## 匿名函数
11. 匿名函数

    1. 从而函数可以访问完整的词法环境（闭包），

    2. ```go
               func square func() int{
               	var x int
               	return func() int {
               		x++
               		return x*x
               	}
               }
               f:=square()
               f()  //为1
               f()  //为4
               q:=square()
               q() //为1
               /*f 相当于是一个闭包，一个环境，然后每次调用都是到那个环境里面，也说明了生命周期不由作用域决定
               且 q 和f 是同一个函数生成的两个闭包（环境）
               闭包的实现： 将函数和其中的值当作一个结构体来传递
               */
               ```
  
    12. 需要递归调用匿名函数的时候，则先将匿名函数赋值给一个变量
    4. > 网页爬取的核心问题是如何遍历一张图
    5. ！ 捕获迭代变量！
        1. 由于保存的是一个环境，所以在循环中，一般引入一个和循环变量同名的局部变量，然后使用这个变量
        1. 匿名函数的作用域捕获的是循环变量的地址，所以循环变量递增，匿名函数环境的中的变量也在递增，但是局部变量每次循环都是不同的地址，不会出现这个问题
        2. 这个问题常出现于在循环中，给一个函数切片（数组）赋值（赋匿名函数）
       3. 以及go 和defer语句也会出现这种问题
            1. 因为他们都是等待循环结束再执行函数值
    
## 可变参数
12. 可变参函数，同c语言的操作，vals ... int 表示可变个 int类型的参数，然后vals被当作int类型的切片
13. 可变参数的可接受一个数组或者values:=[]int{1,2,3}      sum(values...) 在尾部加上...

## defer函数

13. defer函数
    1. 在普通的函数火种方法前加上defer关键字，那么只有包含defer语句的函数执行完时，才会执行defer语句
    1. panic的异常导致的函数结束还是return的结束都是一样的
    3. 多个defer语句的执行顺序和声明顺序相反，（从下往上执行
    4. 用于成对的操作打开关闭，连接断开连接，加锁释放锁
    5. 一个计算函数用时的例子
        5. ```go
                               defer trace("bigSlowOperation")() 
                               
                               func trace(msg string) func() {
                               	start := time.Now()
                               	log.Printf("enter %s", msg)
                               	return func() { log.Printf("exit %s (%s)", msg, time.Since(start)) }
                               }
                               //注意 调用trace的时候，两个括号，这个是，defer 只对结尾的那个括号起了作用，延迟调用了这个函数，从而在起始的时候调用trace函数，并在环境中留下start的值，```
  
  6. defer必须是一个函数调用，不能是赋值语句
7. >  技巧：命名了一个函数的返回值后，可以再增加defer语句，然后就可以每次函数被调用的时候，输出参数和返回值
8. 在循环中使用defer（比如关闭文件）会导致在文件描述符耗尽前都不能关闭文件，因为需要等待循环结束后执行    
   1. 解决办法一般是把关闭文件这样的语句移动到另一个函数（实际上把循环的逻辑代码移动到函数里，循环调用函数），然后每次执行语句调用这个函数